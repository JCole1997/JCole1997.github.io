<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>var和let的区别</title>
    <url>/2020/07/10/var%E5%92%8Clet%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="“var”的缺陷"><a href="#“var”的缺陷" class="headerlink" title="“var”的缺陷"></a>“var”的缺陷</h1><p>在初学JS时，我们就会接触到变量的定义，不同于JAVA这样的静态类型语言，JS只需要通过<code>var</code>便可以声明不同类型的变量。在ES6中又新引入了<code>let\const</code>两种方式来声明变量，表面上<code>var</code>和<code>let</code>的行为都是声明变量，但它们存在区别。</p>
<h2 id="“var”没有块级作用域"><a href="#“var”没有块级作用域" class="headerlink" title="“var”没有块级作用域"></a>“var”没有块级作用域</h2><p>使用<code>var</code>声明的变量不是<em>全局作用域</em>就是<em>函数作用域</em>，而当一个变量在代码块内声明时，“var”会忽略代码块，此时的变量就成了全局变量。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> test = <span class="literal">true</span>; <span class="comment">// 使用 "var" 而不是 "let"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(test); <span class="comment">// true，变量在 if 结束后仍存在</span></span><br></pre></td></tr></table></figure>

<p>因此，会带来一个问题–内层变量可能覆盖外层变量</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 想打印外层的时间</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>; <span class="comment">// 这里声明的作用域为整个函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第一次看到这段代码时，很多初学者会十分疑惑，为什么最后输出的变量<code>tmp</code>是<code>undefined</code>。在这里需要引入一个概念就是<strong>变量提升</strong>。(在这篇<a href="/2020/07/12/JS学习笔记之执行上下文/">博客</a>的“变量对象”里讲的更详细)<br>&emsp;&emsp;具体内容就是：<strong>程序正式执行之前，会将<code>var</code>声明的变量和<code>function</code>声明的函数预读到当前作用域的顶部，但赋值会保留在原位置，在赋值之前变量的值是<code>undefined</code></strong>。同样当函数开始的时候，<code>var</code>声明的变量会在函数开头被定义。<br>&emsp;&emsp;在上面这个例子当中，由于<code>var</code>声明的变量没有块级作用域(<code>if</code>条件语句判断下的内容即是一个代码块)，<code>var tmp = &#39;hello world&#39;</code>声明的变量会被提前至函数开头并覆盖掉了函数外声明的全局变量<code>tmp</code>。声明会被提升，但是赋值不会，<code>tmp</code>此时的值即为<code>undefined</code>。这与我们原本想获取的时间大相径庭。</p>
<hr>
<h1 id="“let”的出现"><a href="#“let”的出现" class="headerlink" title="“let”的出现"></a>“let”的出现</h1><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>为了解决上述问题，ES6新增了<code>let</code>命令，它和<code>var</code>一样用于申明变量，但是声明的变量只在<code>let</code>命令所在的代码块内生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n); <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 10 if代码块内赋值覆盖掉了外层</span></span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n); <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5 代码块内外赋值分开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有声明循环计数器<code>i</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p>不同于使用<code>var</code>，<code>let</code>声明的变量一定要在声明后使用，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>一旦在块级作用域内使用<code>let</code>命令声明变量之前，该变量都是不可用的，这种情况被称之为“暂时性死区”(temporal dead zone)。<br>我们可以结合上一个特点一起理解，也就是要注意一定要在<code>let</code>声明变量后再使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>; <span class="comment">// 声明全局变量tmp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// let声明局部变量tmp绑定此代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h2><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顶层对象属性"><a href="#顶层对象属性" class="headerlink" title="顶层对象属性"></a>顶层对象属性</h2><p>在ES5中，顶层对象的属性与全局变量(使用<code>var</code>声明的变量)是等价的。而ES6改变了这一点，规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<hr>
<p>总的来说，现在编写JS代码时，应当减少有缺陷的<code>var</code>而使用更加“安全”的<code>let</code>进行变量的声明，它为我们提供了更为精细的作用域。当然如果你需要一个变量拥有整个函数作用域，在特定情况下<code>var</code>还是有一定的用武之地。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记之执行上下文</title>
    <url>/2020/07/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<p>经过两天的搜索和学习，我对JS中的执行上下文/执行环境(Execution Context)，执行栈/调用栈(Execution Stack)，变量对象(Variable Object)，活动对象(Activation Object)，作用域链(Scope Chain)等概念有了一定的认知。但由于内容较多，在学习的过程中各个知识点的理解相对杂乱，于是寄希望于通过写博客的方式将这些内容整理起来，方便以后复习和参考。</p>
<hr>
<h1 id="执行上下文的概念和类型"><a href="#执行上下文的概念和类型" class="headerlink" title="执行上下文的概念和类型"></a>执行上下文的概念和类型</h1><p>执行上下文是一个相对抽象的概念，它是执行JavaScript代码的环境。换句话说JavaScript代码需要在执行上下文中运行。</p>
<p>在JavaScript中有三种执行上下文</p>
<ul>
<li><strong>全局执行上下文</strong>—不包括任何函数体内的代码都在全局执行上下文中。一个程序只有一个全局执行上下文</li>
<li><strong>函数执行上下文</strong>—函数执行上下文在函数被调用时创建，函数执行上下文可以有多个。</li>
<li><strong>Eval函数执行上下文</strong>—执行在<code>eval</code>函数内部的代码也会创建它的执行上下文。</li>
</ul>
<hr>
<a id="more"></a>

<h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>执行栈(ECStack)用于存储代码运行时创建的执行上下文，它有栈的特性—后进先出。</p>
<p>在程序的初始化阶段，<em>全局执行上下文</em>会被创建并压入ECStack中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>代码执行过程中如果调用了函数，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  second();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line"></span><br><span class="line"><span class="comment">//当second()被调用时的执行栈</span></span><br><span class="line">ECStack = [</span><br><span class="line">    &lt;second&gt; functionContext,</span><br><span class="line">    &lt;first&gt; functionContext,</span><br><span class="line">    globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>当从<code>first()</code>函数内部调用<code>second()</code>函数时，创建了一个新的执行上下文并把它压入当前执行栈的顶部。当<code>second()</code>函数执行完毕后，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即<code>first()</code>函数的执行上下文。相关代码执行完以后，ECStack只会包含全局上下文(globalContext)，一直到整个应用程序结束，移除全局执行上下文。</p>
<h1 id="执行上下文的属性"><a href="#执行上下文的属性" class="headerlink" title="执行上下文的属性"></a>执行上下文的属性</h1><p>每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<hr>
<h1 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h1><p>我在上一篇<a href="/2020/07/10/var和let的区别/">博客</a>写到了<code>var</code>和<code>let</code>的区别，其中提到了一个概念叫做<strong>变量提升</strong>，在这篇博客中将更深层次地探讨变量在代码运行时，究竟是如何进行声明和赋值。</p>
<h2 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h2><p>变量与执行上下文是有着密切关系的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 全局上下文中的变量</span></span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// 函数上下文中的局部变量</span></span><br><span class="line">&#125;)();</span><br><span class="line"> </span><br><span class="line">alert(a); <span class="comment">// 10</span></span><br><span class="line">alert(b); <span class="comment">// 全局变量 "b" 没有声明</span></span><br></pre></td></tr></table></figure>

<p>因此变量就应该明确的知道自己的数据是存储在全局上下文(全局变量)还是函数上下文(局部变量)，并且知道该如何访问，这种机制就被称为变量对象(variable object)。</p>
<blockquote>
<p>变量对象(VO)是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：</p>
<ul>
<li>变量 (var, 变量声明);</li>
<li>函数声明 (FunctionDeclaration);</li>
<li>函数的形参</li>
</ul>
</blockquote>
<p>当我们声明一个变量或者一个函数的时候就相当于创建了变量对象的新属性<br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">test(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>对应变量对象为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局上下文的变量对象</span></span><br><span class="line">VO(globalContext) = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  test: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">// test函数上下文的变量对象</span></span><br><span class="line"><span class="xml">VO(test functionContext) = &#123;</span></span><br><span class="line"><span class="xml">  x: 30,</span></span><br><span class="line"><span class="xml">  b: 20</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="全局上下文中的变量对象"><a href="#全局上下文中的变量对象" class="headerlink" title="全局上下文中的变量对象"></a>全局上下文中的变量对象</h2><blockquote>
<p>全局变量(Global object)：是在进入任何执行上下文之前就已经创建了的对象；这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。</p>
</blockquote>
<p>全局对象：<br>1.可以通过<code>this</code>进行引用，在浏览器中，全局对象就是<code>Window</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>
<p>2.全局对象是由<code>Object</code>构造函数实例化的一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>3.预定义了许多函数和属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 都能生效</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.Math.random());</span><br></pre></td></tr></table></figure>
<p>4.作为全局变量的宿主。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>5.客户端JavaScript中，全局对象有window属性指向自身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.window.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>简单来说，<strong><em>全局上下文中的变量对象就是全局对象</em></strong></p>
<hr>
<h2 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h2><p>在函数上下文中，变量对象(VO)是不能直接访问的，此时我们用活动对象(activation object,缩写为AO)代替VO。<br>同样，活动对象是在进入函数上下文时刻被创建，它通过函数的<code>arguments</code>属性初始化<code>arguments</code>属性值是<code>Arguments</code>对象。</p>
<hr>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码被分为两个阶段进行处理：<br>1.进入执行上下文<br>2.执行代码<br>全局上下文和函数上下文的处理过程是一样的</p>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，VO里包含了下列属性：</p>
<p>1.<strong>函数的所有形参</strong>(如果是在函数执行上下文中)</p>
<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有传递对应参数的话，那么由名称和undefined值组成的一种变量对象的属性也将被创建</li>
</ul>
<p>2.<strong>所有函数声明</strong></p>
<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
<p>3.<strong>所有变量声明</strong></p>
<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>在进入执行上下文后，这时候的<code>AO</code>是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">undefined</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值<br>所以上面例子里的<code>AO</code>在代码执行完成后是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        length: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个有代表性的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(x); <span class="comment">// function</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">alert(x); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>为什么第一个<code>alert(x)</code>的返回值是<code>function</code>，为什么在<code>x</code>声明前就可以访问到，为什么不是10或者20呢？<br>因为，函数声明是在<strong>进入上下文</strong>时填入的，并且<em>变量声明的顺序在形参和函数声明之后</em>，且在<strong>进入上下文</strong>阶段，<em>变量声明不会干扰VO中已经存在的同名函数或形参声明</em>。(函数声明的优先级高于变量声明)。<br>看到这里的时候，应该对变量提升这个概念又有了新的理解。</p>
<hr>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>什么是作用域链，为什么需要作用域链，我们根据下面这个例子来了解</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(x + y);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> bar; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo()(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>很明显，每个上下文都拥有自己的变量对象：对于全局上下文，它是全局对象自身，对于函数，它是活动对象。上面这个例子中，<code>bar()</code>函数是<code>foo()</code>函数的内部函数，通过作用域链，<code>bar()</code>函数内部可以获取到 x,y 两个变量的数据。<br>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<p>下面以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p>
<h2 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h2><p>在变量对象我们提到，在进入上下文时，函数声明放在变量/活动对象中。让我们看看在全局上下文中的变量和函数声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  alert(x + y);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>这里，我们看到变量“y”在函数“foo”中定义，却并未看见“x”在“foo”上下文中声明，并且“foo”上下文的活动对象中也仅包含一个“y”属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fooContext.AO = &#123;</span><br><span class="line">  y: <span class="literal">undefined</span> <span class="comment">// undefined – 进入上下文的时候是20 – at activation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以此时，函数“foo”需要借助一个机制来访问到更高层上下文的变量对象。<br>这种机制是通过函数内部的<code>[[scope]]</code>属性来实现的。</p>
<blockquote>
<p>[[scope]]是所有父变量对象的层级链，处于当前函数上下文之中，在函数创建时存于其中。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
</blockquote>
<p><code>[[scope]]</code>在函数创建时就被存储直至函数销毁。(即使函数未调用，<code>[[scope]]</code>以保存于函数对象中)<br>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数创建时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。这时候执行上下文的作用域链，我们命名为<code>Scope</code><br><code>Scope = [AO].concat([[Scope]]);</code><br>上面代码的意思是：活动对象是作用域数组的第一个对象，即添加到作用域的前端。<br>这样一来，在标识符进行解析时从作用域中变量对象进行连续查找，从最深的上下文开始，一直到最上层(全局上下文)。在向上查找中，一个上下文中的局部变量较之于父作用域的变量拥有较高的优先级。万一两个变量有相同的名称但来自不同的作用域，那么第一个被发现的是在最深作用域中。</p>
<p>举个例子巩固理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line">    alert(x +  y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>
<p>1.<br>全局上下文的变量对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalContext.VO === Global = &#123;</span><br><span class="line">  x: <span class="number">10</span></span><br><span class="line">  foo: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>在“foo”函数创建时，它的“[[scope]]”属性值为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.[[Scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>2.<br>在“foo”激活时（进入上下文），“foo”上下文的活动对象是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fooContext.AO = &#123;</span><br><span class="line">  y: <span class="number">20</span>,</span><br><span class="line">  bar: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>“foo”上下文的作用域链为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.[[Scope]] = [</span><br><span class="line">  fooContext.AO,</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>内部函数“bar”创建时，其[[scope]]为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bar.[[Scope]] = [</span><br><span class="line">  fooContext.AO,</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>3.在“bar”激活时，“bar”上下文的作用域链为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">barContext.Scope = [</span><br><span class="line">  barContext.AO,</span><br><span class="line">  fooContext.AO,</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2020/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树结点的定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
 <a id="more"></a>

<h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">leetcode-114</a></p>
</blockquote>
<p>二叉树的前序遍历的访问顺序：根节点-&gt;左子树-&gt;右子树</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>前序遍历的<strong>递归</strong>实现<br>1.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> preorderTraversalHelper = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node) &#123;</span><br><span class="line">            res.push(node.val);</span><br><span class="line">            preorderTraversalHelper(node.left);</span><br><span class="line">            <span class="comment">//遍历左子树</span></span><br><span class="line">            preorderTraversalHelper(node.right);</span><br><span class="line">            <span class="comment">//遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preorderTraversalHelper(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>使用递归较为简单，我们再用<strong>迭代</strong>实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [], stack = [];</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cur = stack.pop();</span><br><span class="line">        res.push(cur.val);</span><br><span class="line"></span><br><span class="line">        cur.right &amp;&amp; stack.push(cur.right);</span><br><span class="line">        <span class="comment">//因为使用数组来模拟栈，因此先将右节点放入数组</span></span><br><span class="line">        cur.left &amp;&amp; stack.push(cur.left);</span><br><span class="line">        <span class="comment">//后入数组的数据将先弹出，从而先遍历左节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">leetcode-94</a></p>
</blockquote>
<p>二叉树的中序遍历的访问顺序：左子树-&gt;根节点-&gt;右子树</p>
<h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><p>中序遍历的<strong>递归</strong>实现，基本与前序类似</p>
<p>1.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> inorderTraversalHelper = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        inorderTraversalHelper(node.left);</span><br><span class="line">        res.push(node.val);</span><br><span class="line">        inorderTraversalHelper(node.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    inorderTraversalHelper(root)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h2><p>中序遍历的<strong>迭代</strong>实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [], stack = [];</span><br><span class="line">    <span class="keyword">while</span>(root || stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//不断将左子树入栈</span></span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">leetcode-145</a></p>
</blockquote>
<p>二叉树的前序遍历的访问顺序：左子树-&gt;右子树-&gt;根节点</p>
<h2 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h2><p>1.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? [...postorderTraversal(root.left), ...postorderTraversal(root.right), root.val] : [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> postorderTraversalHelper = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        postorderTraversalHelper(node.left);</span><br><span class="line">        postorderTraversalHelper(node.right);</span><br><span class="line">        res.push(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    postorderTraversalHelper(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h2><p>二叉树的后序遍历有一个十分巧妙的办法<br><em>前序</em>遍历的访问顺序为<strong>根&gt;左&gt;右</strong><br><em>后序</em>遍历的访问顺序为<strong>左&gt;右&gt;根</strong></p>
<p>如果此时将<em>前序</em>遍历结果逆序(push -&gt; unshift)，那么输出结果则是<strong>右&gt;左&gt;根</strong><br>此时只需调整<strong>左右</strong>子树的入栈顺序便可得到<em>后序</em>遍历的<strong>左&gt;右&gt;根</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [], stack = [];</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop();</span><br><span class="line">        res.unshift(node.val);</span><br><span class="line"></span><br><span class="line">        node.left &amp;&amp; stack.push(node.left);</span><br><span class="line">        node.right &amp;&amp; stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">leetcode-102</a></p>
</blockquote>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>二叉树的层次遍历通常使用<strong>BFS</strong>(宽度优先搜索)的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取队列长度，即二叉树当前层次结点个数</span></span><br><span class="line">        <span class="keyword">let</span> queueLength = queue.length;</span><br><span class="line">        <span class="comment">//本题输出为二维数组，每层结点构成一个一维数组</span></span><br><span class="line">        res.push([]);</span><br><span class="line">        <span class="comment">//for循环当前层数的所有结点，并将它们的子结点按照先左后右的方式入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queueLength; i++) &#123;</span><br><span class="line">            <span class="comment">//队列的先入先出</span></span><br><span class="line">            <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">            res[res.length - <span class="number">1</span>].push(node.val);</span><br><span class="line">            </span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">levelOrderHelper</span>(<span class="params">root, depth</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!res[depth]) &#123;</span><br><span class="line">            res[depth] = []</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res[depth].push(root.val);</span><br><span class="line">        levelOrderHelper(root.left, depth + <span class="number">1</span>)</span><br><span class="line">        levelOrderHelper(root.right, depth + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  levelOrderHelper(root, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树相关题目</title>
    <url>/2020/07/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树结点的定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<hr>
 <a id="more"></a>

<h1 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h1><p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">leetcode-100</a></p>
<p>题目描述：<br>给定两个二叉树，编写一个函数来检验它们是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br>示例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入:      <span class="number">1</span>         <span class="number">1</span></span><br><span class="line">          / \       / \</span><br><span class="line">         <span class="number">2</span>   <span class="number">3</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="递归-DFS"><a href="#递归-DFS" class="headerlink" title="递归/DFS"></a>递归/DFS</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若两节点都不存在，相同</span></span><br><span class="line">    <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 两节点有一个不存在，不相同</span></span><br><span class="line">    <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断两节点数值，并判断p,q的左子树以及右子树是否相同，进行递归</span></span><br><span class="line">    <span class="keyword">return</span> p.val === q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">leetcode-101</a></p>
<p>题目描述：<br>给定一个二叉树，检查它是否是镜像对称的。<br>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">           <span class="number">1</span></span><br><span class="line">          / \</span><br><span class="line">         <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">        / \ / \</span><br><span class="line">       <span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br><span class="line">二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>] 是对称的。</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>此题递归解法与<strong>相同的树</strong>高度类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? helper(root.left, root.right) : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(!left || !right) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> left.val === right.val &amp;&amp; helper(left.right, right.left) &amp;&amp; helper(left.left, right.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> leftStack = [root.left];</span><br><span class="line">    <span class="keyword">let</span> rightStack = [root.right];</span><br><span class="line">    <span class="keyword">while</span>(leftStack.length &amp;&amp; rightStack.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = leftStack.pop();</span><br><span class="line">        <span class="keyword">let</span> right = rightStack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left || !right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val !== right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        leftStack.push(left.left);</span><br><span class="line">        rightStack.push(right.right);</span><br><span class="line">        leftStack.push(left.right);</span><br><span class="line">        rightStack.push(right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leftStack.length || rightStack.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">leetcode-104</a></p>
<p>题目描述：<br>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回最大深度 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> leftDepth = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">let</span> rightDepth = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h1><p>题目描述：<br>根据一棵树的前序遍历与中序遍历构造二叉树。<br>注意:<br>你可以假设树中没有重复的元素。<br>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h2 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!preorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    <span class="keyword">let</span> midIndex = inorder.indexOf(rootVal);</span><br><span class="line"></span><br><span class="line">    root.left = buildTree(preorder.slice(<span class="number">1</span>, midIndex + <span class="number">1</span>), inorder.slice(<span class="number">0</span>, midIndex));</span><br><span class="line">    root.right = buildTree(preorder.slice(midIndex + <span class="number">1</span>), inorder.slice(midIndex + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归改进版"><a href="#递归改进版" class="headerlink" title="递归改进版"></a>递归改进版</h2><ul>
<li>字符串截取 slice 性能消耗比较大，没必要把 preorder 和 inorder 数组真的切割出来</li>
<li>用两个指针表示即可。写一个 helper 函数，接收2对指针</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">preorder, p_start, p_end, inorder, i_start, i_end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p_start &gt; p_end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> rootVal = preorder[p_start];</span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    <span class="keyword">let</span> midIndex = inorder.indexOf(rootVal);</span><br><span class="line">    <span class="keyword">let</span> leftNums = midIndex - i_start;</span><br><span class="line"></span><br><span class="line">    root.left = helper(preorder, p_start + <span class="number">1</span>, p_start + leftNums, inorder, i_start, midIndex - <span class="number">1</span>);</span><br><span class="line">    root.right = helper(preorder, p_start + leftNums + <span class="number">1</span>, p_end, inorder, midIndex + <span class="number">1</span>, i_end);</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
</search>
